{"id": 629236, "slug": "c64-well", "name": "C64-Well", "name_original": "C64-Well", "description": "<p>For some reason, you thought it really was a good idea to take your robot exosuit into that deep dark hole. It couldn't possibly be infinite could it? And if there's as much energy down there as your scanner says there is, you could be set for life.</p>\n<p>Never mind that your exosuit's battery can't hold a charge (it leaks like a sieve), and oh\u2014there's horrible energy sucking spikes that are suddenly arriving from below.\u00a0</p>\n<p>Yeah, this was a great idea.\u00a0</p>\n<p><strong>Controls &amp; Gameplay</strong><br/></p>\n<p>Navigate using the joystick in port #2 (browser version is configured to use the arrow keys). Land on platforms for a brief respite from gravity. But don't stay still too long; your battery has to expend energy to keep you alive. You can jump (press UP), but make sure it's worth it\u2014that costs a lot of energy.</p>\n<p>You have 200 units of energy. You need to find hearts to recharge. Avoid the spikes\u2014they drain your energy precipitously.\u00a0</p>\n<p>You earn money for each screen you clear based on the amount of energy you have available. How much can you earn?</p>\r\nbattery discharge-0.16horizontal movement-0.1jump-12spike-50heart+10\r\n<p><strong>#asciibasic10liner entry</strong></p>\n<p>This game was created for the #asciibasic10liner challenge. As such, this is probably some of the worst code I've ever written! Nevertheless, I'll attempt an explanation of my logic.</p>\n<p><strong>Init (0-2)</strong><br/></p>\r\n\r\n0 w$=cH(166):pc=88:l$=cH(5)+w$+w$+w$+w$+w$:f=40:ec=83:sp=30:h=102:p=1964\r\n\r\n<p>This is the initialization section to define the variables that we're using throughout the game.\u00a0</p>\n<ul><li>w$ is the wall character.</li><li>l$ (ledge) is a combination of these wall characters.\u00a0</li><li>f (forty) is just short for the constant 40 (used for screen width)</li><li>ec is the character code for the heart</li><li>sp is the character code for the spikes</li><li>h is the character code for the wall</li><li>p is the memory position for the player (in screen memory). We don't use X and Y positioning -- we just have a single address to save some space.</li></ul>\r\n\r\n1 g$(0)=cH(30)+\"S\":g$(1)=cH(28)+\"^^^^\":g$(2)=cH(28)+\"^\":j=56320:l=.35:a=16\r\n\r\n<p>More initialization.</p>\n<ul><li>g$ is additional graphics. g$(0) is the heart (energy). g$(1) is a series of red spikes. g$(2) is a single red spike.</li><li>j is the poke address to read the joystick.</li><li>l is the chance a ledge (and corresponding graphics -- heart or spikes)\u00a0will appear</li><li>a is the valid position range for the ledges.</li></ul>\r\n\r\n2 u=f*3:c$=\"{clr}\":dId(256):d(123)=-1:d(119)=1:d(126)=0:z$=\"{left}\":goS7\r\n<p>More initialization!</p>\n<ul><li>u is the distance one can jump up -- currently 40*3 or 120.</li><li>c$ is short for \"clear screen\" string.</li><li>We dimension d (delta) for 256 entries. Joystick Left (123)\u00a0and Right(119) get -1 and 1 respectively. 126 is equivalent to Joystick UP. We set to zero initially; jumping only works from a ledge.</li><li>z$ is used for moving the cursor left.</li><li>Call the routine at line 7 (draw new screen).</li></ul>\n<p><strong>Gameplay Loop (3-6)</strong></p>\n<p>The gameplay loop takes keyboard input from the user and updates the player's position. It determines if the player has touched a heart, a spike, or a wall. It also updates the player's energy use and displays their energy and score on the screen.</p>\r\n\r\n3 x=d(pE(j)):w=pE(p+x):n=p-(w&lt;&gt;h)*x:b=pE(n+f):n=n-(b&lt;&gt;h)*f:d(126)=(b=h)*u\r\n<ul><li>x (player delta) is looked up from the d (delta) array, which is based on the current joystick reading.\u00a0</li><li>We read the character at the player's intended location into w (wall).</li><li>n (new position) is calculated from p (player position). We use the fact that BASIC returns -1 for a comparision that is true to only change the position if the player player delta was set, and if there's no wall in the way.</li><li>b (bottom) is used to detect below the player. Instead of looking to the new position horizontally, it looks down (+f, or +40). If there's no wall underneath, the player moves down a line (40 characters)</li></ul>\r\n\r\n4 e=e+(w=ec)*10+(b=ec)*10+(w=sp)*-50+(b=sp)*-50:q=iN(q):ifn&lt;&gt;ptHpoKp,32\r\n<ul><li>e (energy) is used to store the player's remaining energy. It counts UP (relying on BASIC's default of 0 for uninitialized variables).</li><li>The player gains 10 units if they touch a heart (ec), and loses 50 units if they touch a spike. The studious reader will catch that this isn't perfect; it's possible to read that the player has touched a heart or a spike when it's not obvious they've done so on screen.</li><li>q (points) is used to store the player's score. It increases only whenever the player advances a screen. It's used loosely as money in the display. Here we convert it to an integer so BASIC isn't showing the user any decimal portion.</li><li>Finally, if the new player position (np) is different from the previous player position (pp), poke a space at the previous position to clear the player's avatar.</li></ul>\r\n\r\n5 p=n:poK54272+p,4:poKp,pc:pR\"{home}{down}$\"q;z$\" \":ifp&gt;1943tHgoS7\r\n<ul><li>The new position is assigned to the player's position, and the player's avatar is poked into screen memory. 54272+p is used to poke the player character's color. Because p is an index to screen memory from 0 (not 1024 like you might expect), the 54272 constant here is lower than you'd expect when referring to color memory.</li><li>Next, we print the player's score (money). We do it a line below the top (the top line will be their energy.)</li><li>The player's position is checked, and if it's near the bottom of the screen, we call the screen redraw routine to render the next part of the level</li></ul>\r\n\r\n6 e=e+0.16+.1*abs(x):pR\"{home}S\"iN(205-e)z$\" \":on(e&gt;205)+1goT3:pRc$\"$\"q:eN\r\n<ul><li>Keeping the player alive costs energy. We're always subtracting a fractional portion. In practice this means that the longer the player goes without accumulating hearts, the less money they will make as they advance.</li><li>The player's energy is also impacted based on their movement. Jumping is significantly more costly than horizontal movement.</li><li>The player's energy is printed in the top left of the screen.</li><li>If the player hasn't exhausted their energy, we repeat the whole process (go back to line 3).</li><li>But if they are out of energy, we clear the keyboard buffer, clear the screen, and print their score before ending.</li><li>\u00a0Note the use of \"on goto\" here; by abusing how a true conditional is evaluated to -1 and a false one evaluates to zero, we can create an else/then like structure. If e&gt;205, the game is over because the value is \"true(-1) + 1\" will be zero. On Goto is 1-based, meaning that the branch is never taken. If e&gt;205 is not true, however, we get \"false(0)+1\", and that does match to the first line in the list, and we take the branch.</li></ul>\n<p><strong>Draw new screen (7-9)</strong></p>\n<p>This routine draws the next portion of the level, including ledges, hearts, and spikes. It also accumulates the user's score.</p>\r\n\r\n7 pRc$:fOz=1to22:pR:ifrN(0)&lt;ltHc=rN(0)*a+9:pRsPc)l$;:fOg=1toc:pRz$;:neX\r\n<ul><li>Clear the screen.</li><li>We go from the top of the screen to the bottom, randomly printing ledges.</li><li>If we print a ledge, we also backtrack to the beginning of the line by printing a lot of left characters (z$)</li></ul>\r\n\r\n8 poK53281,0:q=q+(205-e)/85:ifrN(0)&lt;ltHc=rN(0)*a+9:pRsPc)g$(rN(0)*3);\r\n<ul><li>Set the background color\u00a0to black. I wanted this in the init section, but there wasn't room. This does mean there can be slight screen flicker as the layer draws.</li><li>Accumulate a score for the user, for each line on the screen. The more energy the user has, the better the score will be.</li><li>There's also a chance that we'll display one of our three graphics -- this can be a heart, a row of spikes, or a single spike. It may obliterate some of the ledges we just printed.</li></ul>\r\n\r\n9 neX:pR\"{home}\";:fOz=1to24:pRsP8)cH(5)w$sP20)w$:neX:p=p-960:reT\r\n<ul><li>Finish the loop, go to the top left of the screen, and print the walls of the well.</li><li>We move the player back to the top of the screen by subtracting 960 (24 lines of 40 characters)</li><li>... and we return to the caller.</li></ul>\n<p><strong>Why the C64?</strong></p><p><strong>The C64 was my first personal computer as a kid, and I learned the basics of programming on it. I still have it, and it still works, although it could use some restoration.</strong><br/></p><p><strong><br/>Thanks\u00a0</strong></p>\n<ul><li>Downwell, which game me the inspiration for level layout.</li><li>To\u00a0https://commocore.itch.io/mathsticks-10\u00a0for making me aware of https://lvllvl.com/c64/\u00a0to supply a browser-playable version of the game.</li><li>VICE's `petcat` utility for making it easy to easily automate the build &amp; test process on my Mac!</li></ul>\n<p><strong>Note</strong></p>\n<p>If you want to convert the BASIC source code to a PRG file, you need to use VICE's petcat utility. You can find it in the VICE bundle after installation.</p>\r\n\r\npetcat -w2 -o c64well.prg -- c64well.bas<br/>", "metacritic": null, "released": "2021-06-28", "tba": false, "updated": "2021-07-02T11:40:28", "background_image": "https://media.rawg.io/media/screenshots/376/3761a03861fa841002900883b43a5e41.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 15, "game_series_count": 0, "reviews_count": 0, "platforms": ["Web"], "developers": ["Kerri Shotts"], "genres": ["Platformer"], "publishers": [], "esrb_rating": null}