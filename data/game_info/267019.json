{"id": 267019, "slug": "breakout-280", "name": "Breakout 280", "name_original": "Breakout 280", "description": "<p>Here's a Breakout clone that fits in a single tweet (this version is three two characters shorter than the original). Use the mouse to control the paddle. The game will start right after loading/resetting so be ready to catch the ball. The game is made for PICO-8. See below the original and the commented version of the source code and follow me on Twitter to see more similar things.</p>\r\n1\r\n2\r\n3\r\n4\r\n5b,a={64,99},{.5,-1}poke(24365,1)memset(0,153,9215)::_::for z=0,5 do\r\ncls()map()rect(0,0,127,128)p=stat(32)rect(p-8,126,p+8,127)i=z%2+1y=b[i]\r\nb[i]+=a[i]if(pget(b[1],b[2])&gt;0)mset(b[1]/8,b[2]/8,0)a[i]*=-1 b[i],a[i-1]=y,b[2]&gt;119 and(b[1]-p)/8 or a[1]\r\nend\r\npset(b[1],b[2])flip()goto _\r\n\r\n\r\n<p>And here is the annotated version:</p>\r\n\r\n 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6\r\n 7\r\n 8\r\n 9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n32\r\n33\r\n34\r\n35\r\n36\r\n37\r\n38\r\n39\r\n40\r\n41\r\n42\r\n43\r\n44\r\n45\r\n46\r\n47\r\n48\r\n49\r\n50\r\n51\r\n52\r\n53\r\n54\r\n55\r\n56\r\n57\r\n58\r\n59\r\n60\r\n61\r\n62\r\n63\r\n64\r\n65\r\n66\r\n67\r\n68\r\n69\r\n70\r\n71\r\n72\r\n73\r\n74\r\n75\r\n76\r\n77\r\n78\r\n79\r\n80\r\n81\r\n82\r\n83\r\n84\r\n85\r\n86-- set up ball position (b) and velocity vector (a)\r\n-- start game with the ball moving up-right\r\nb,a={64,99},{.5,-1}\r\n-- enable mouse controls\r\npoke(24365,1)\r\n-- fill sprite data and the top part of the map with 153\r\n-- the sprite data starts at address 0 and the map is right\r\n-- after it. this makes all the sprites orange (one byte encodes\r\n-- two pixels in a sprite, 153 -&gt; 0x99 in hex -&gt; 9 is the index\r\n-- for the orange color) and the map is filled with tile 153. as\r\n-- long as the map has nonzero tiles this will work as all the\r\n-- sprites/tiles are now full orange.\r\nmemset(0,153,9215)\r\n-- loop label for game logic start\r\n::_::\r\n-- loop six times per displayed frame so the gameplay is faster\r\n-- this needs to be a number divisible by two (see below why)\r\n-- the real multiplier for speed is actually three (see below)\r\nfor z=0,5 do\r\n  cls()\r\n  -- just draw the whole map - only the top part was filled above\r\n  map()\r\n  -- draw playfield borders\r\n  rect(0,0,127,128)\r\n  -- take paddle positio (p) n from mouse x coordinate\r\n  p=stat(32)\r\n  -- draw 16 pixel wide paddle at paddle position on bottom of the\r\n  -- screen\r\n  rect(p-8,126,p+8,127)\r\n  -- build an index counter (i) from the frame loop counter (z)\r\n  -- the index counter can now be used to access both of the ball\r\n  -- position and velocity components (x and y, 1 and 2) with the\r\n  -- same code -- it first moves the ball horizontally and then\r\n  -- vertically on the next frame loop. effectively there is no\r\n  -- diagonal movement (it does look like that, though)\r\n  i=z%2+1\r\n  -- store the previous value of the current position component\r\n  y=b[i]\r\n  -- move ball along the current axis using the velocity vector\r\n  b[i]+=a[i]\r\n  -- check for collision (pixel value under the ball is non-zero)\r\n  if pget(b[1],b[2])&gt;0 then\r\n    -- the if-statement uses a pico8 preprocessor shorthand that\r\n    -- allows for shorter code. here it is written using the standard\r\n    -- if-then-end structure instead of the if(x) structure\r\n\r\n    -- zero the map tile under the ball (each tile is 8x8 so we\r\n    -- need to divide the ball coordinate by 8 to access the correct\r\n    -- tile)\r\n    mset(b[1]/8,b[2]/8,0)\r\n    -- the grouped assignments are written in long form here.\r\n    -- put the stored previous value back in the coordinate (the ball\r\n    -- hit something so move it back outside whatever it hit)\r\n    b[i]=y\r\n    -- reverse the velocity component -- bounce! note that this could\r\n    -- also be written like a[i]*=-1 (a[i] = -1 * a[i]) but this can't\r\n    -- be done\r\n    a[i]=-a[i]\r\n    -- this is sneaky: the [i-1] is used to access the x component\r\n    -- of the velocity vector (a) when we are processing the y\r\n    -- component (i == 2, i-1 == 1): it will set index zero when\r\n    -- processing x (i == 1, i-1 == 0) but that is never used. this\r\n    -- sets the x component of the velocity vector based on the\r\n    -- paddle position. the more to the left of the paddle hits, the\r\n    -- more left motion the velocity will have and vice versa.\r\n    -- if the position y component (b[2]) is over 119 (we know all\r\n    -- hits will be a hit with the paddle instead of the top\r\n    -- wall/bricks) -- otherwise it just reassigns the original\r\n    -- value (a[1] == velocity x).\r\n    --\r\n    -- this could be written as follows (but it's two chars longer):\r\n    --\r\n    -- if b[2]&gt;119 then\r\n    --  a[i-1]=(b[1]-p)/8\r\n    -- end\r\n    a[i-1]=b[2]&gt;119 and(b[1]-p)/8 or a[1]\r\n    -- end of collision logic\r\n  end\r\n  -- end of frame loop\r\nend\r\n-- draw the ball at the ball position\r\npset(b[1],b[2])\r\n-- flip the frame\r\nflip()\r\n-- loop to beginning of game logic\r\ngoto _", "metacritic": null, "released": "2018-11-17", "tba": false, "updated": "2019-01-09T12:41:06", "background_image": "https://media.rawg.io/media/screenshots/585/585936eb2694b17fa17e15aab4eec71d.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 2, "game_series_count": 0, "reviews_count": 0, "platforms": ["Web"], "developers": ["kometbomb"], "genres": ["Action"], "publishers": [], "esrb_rating": null}