{"id": 201440, "slug": "space-bounce-kklam8y", "name": "Space Bounce (kklam8Y)", "name_original": "Space Bounce (kklam8Y)", "description": "<p>WebGL Scene </p><p>By Vadim Romanov</p><p>Web GL Report </p><p>Scene Name: Space Bounce</p><p>K1323598</p><p>Extension of shader.html</p><p>Added random colours per vertex to go with the vertex animations. The vertex animation is now based on sin wave instead of random values with min and max values.</p><p>The middle sphere is illuminated using directional lighting. The direction of the light is based on mouse X and Y coords. </p><p>uniforms.lightDir.value = new THREE.Vector3(mouseX, -mouseY, 0.5);</p><p>There is another sphere that is animated. This smaller sphere starts at a point away from the centre sphere which is its vector direction reference initially. When the small sphere reaches an edge, it will reflect/bounce of it and head in another direction.</p><p>Function for bouncing called every frame in animate.</p><p>function replaceOutBounds(_sphere)</p><p> {</p><p>var boundXUpper = 140;</p><p>var boundXLower = -140;</p><p>var boundYUpper = 80 ;</p><p>var boundYLower = -80;</p><p>if (_sphere.position.x &lt; boundXLower)</p><p> {</p><p>if(Math.sign(initialPosX) == 1)</p><p> initialPosX = -initialPosX;</p><p>if(Math.sign(initialPosX) == -1)</p><p> initialPosX = initialPosX;</p><p> }</p><p>if (_sphere.position.x &gt; boundXUpper)</p><p> {</p><p>if (Math.sign(initialPosX) == 1)</p><p> initialPosX = initialPosX;</p><p>if (Math.sign(initialPosX) == -1)</p><p> initialPosX = -initialPosX;</p><p> }</p><p>if ( _sphere.position.y &lt; boundYLower)</p><p> {</p><p>if (Math.sign(initialPosY) == 1)</p><p> initialPosY = -initialPosY;</p><p>if (Math.sign(initialPosY) == -1)</p><p> initialPosY = initialPosY;</p><p> }</p><p>if (_sphere.position.y &gt; boundYUpper)</p><p> {</p><p>if (Math.sign(initialPosY) == 1)</p><p> initialPosY = initialPosY;</p><p>if (Math.sign(initialPosY) == -1)</p><p> initialPosY = -initialPosY;</p><p> }</p><p>return Math.sqrt(Math.pow(initialPosX, 2) + Math.pow(initialPosY, 2));</p><p> }</p><p>The centre sphere's texture changes based on the distance of the 2 spheres. </p><p>Code from fragment shader responsible for the texture blending </p><p> vec4 texColor = texture2D(tex, texCoords);</p><p> vec4 texColorAlt = texture2D(texAlt, texCoords);</p><p> vec4 c = texColor;</p><p> float dst = distance*0.008;</p><p> if(texColorAlt.r &lt; dst &amp;&amp; texColorAlt.g &lt; dst &amp;&amp; texColorAlt.b &lt; dst)</p><p> c = texColorAlt;</p><p>The stars in the background are randomly positioned spheres in a scene. They flicker synchronously. The flickering is done using another simple shader and sin wave to change the intensity of the whitness of the star.</p><p>Code for the flicker:</p><p> vec3 col = vec3(1, 1, 1);</p><p> col *= (flickerAmount);</p><p> gl_FragColor = vec4(col + vec3(0.1, 0.1, 0.1), 1.0);</p>", "metacritic": null, "released": "2017-03-23", "tba": false, "updated": "2019-01-09T12:41:06", "background_image": "https://media.rawg.io/media/screenshots/acc/acc22b39a0952e561e7d6d4750b43947.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 8, "game_series_count": 0, "reviews_count": 0, "platforms": ["Web"], "developers": ["kklam8Y"], "genres": [], "publishers": [], "esrb_rating": null}