{"id": 111824, "slug": "downtown-bazooka", "name": "Downtown Bazooka", "name_original": "Downtown Bazooka", "description": "Overview<p>Downtown Bazooka is a 3D action exploration game inspired by Tron and Mad Max. It was developed with members from the Video Game Development Club at UCI over the course of the 2015-2016 school year. I was the main programmer and was accompanied by a gameplay programmer, sound designer, and producer.</p>Engine Features<ul><li>Custom physics solution<ul><li>Spacial partitioning using octrees</li><li>Collision events sent to Entity system for gameplay programming</li><li>Axis-aligned bounding box collisions<ul><li>static, dynamic, and trigger colliders</li><li>triggers will pass through dynamics but still call collision events</li><li>dynamics will collide with everything even while moving (enemy stacking)</li></ul></li><li>Heightmap terrain collisions</li><li>Debug rendering system</li></ul></li><li>Transform / Entity system with support for 3D position, rotation, scale, and parenting</li><li>Noise generation and Math utility classes<ul><li>supports simplex and worley (cell) noise generation with fractal variants</li><li>used to procedurally generate city and terrain</li></ul></li><li>Flexible particle system</li><li>Bloom shader and full screen shader support</li><li>Text rendering for menu and instructions screen </li><li>Sound effect and music playback system</li></ul>What I Learned<p>The primary reason of this project was to learn more about C++ and actually make my own game engine with it. In the process I also learned much about OpenGL and physics. While the engine was mostly from scratch, I did use SFML for the OpenGL bindings, 2D UI rendering, and audio support.</p><p>Oh boy was this challenging. So many things I took for granted with Unity ended up being huge hurdles and roadblocks during development. Here's a short list of the most time consuming parts of the engine:</p><ul><li>Rendering code (mesh handling, shaders, particles etc), so many different ways to handle this. Ended up just super optimizing cube drawing using instancing, since basically everything in the game is cubes except terrain.</li><li>Transform / Entity system (TONS of matrix math making sure they combine in correct order to have proper parent child relationships)</li><li>Physics... even as basic as it was with just AABBs, 3 different collider types, and collision callback events, it still took tons of time, and never really worked 100%. I don't even care though, I am so proud of that code. It worked most of the time anyways... XD</li></ul><p>Overall it was a very rewarding experience, despite the pain and torment of not using an engine. It really made me appreciate Unity and everything it does for you. But man, there's nothing like seeing your game boot up super fast as a raw C++ app, feels so badass, haha!</p>Github Project<br/><br/>Play Instructions<p>The goal of the game is to get to each waypoint and then defeat the final boss. To do this you must use your rocket jump ability (left click) to blast yourself around the map. Be careful for enemies and when the ground turns to lava! Good luck!</p>", "metacritic": null, "released": "2016-10-12", "tba": false, "updated": "2019-01-09T12:41:06", "background_image": "https://media.rawg.io/media/screenshots/8d5/8d5d9ae10f50297c2b5c6b810ec6fcbf.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 93, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["jfc3"], "genres": [], "publishers": [], "esrb_rating": null}