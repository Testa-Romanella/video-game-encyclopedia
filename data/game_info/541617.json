{"id": 541617, "slug": "corewar", "name": "Corewar", "name_original": "Corewar", "description": "<p><strong>Corewar</strong> is played between two programs written in Redcode, a low-level language similar to assembly.</p>\n<p>Players write a program to eliminate all opponents in the memory (core) of the virtual computer.</p>\n<p>The \"sandbox\" goal of Corewar is to write code that will cause your opponent code to terminate. A set of challenges with incremental difficulty (like in all Zachlikes) is yet to be created.</p>\n<p>Each location in memory contains an instruction and two values A and B. A and B are used as address pointers when the instruction is executed. A and B may also be used as data when referenced by another instruction.</p>\n<p>This game is part of the Zachlike Jam and currently work in progress.</p>\n\n<p>The above screen with the dancing letters shows a 800 cell memory (core), with 1 instruction per memory location. The letters represent the first character of the opcode stored in that memory location (so D=DAT, M=MOV, J=JMP, etc). The blue/red color shows who \"owns\" (has written) that memory cell and the highlights show the instructions pointers for all the processes of that color.</p>\r\nExample warrior code\r\n<p>This program will overwrite every 4th memory position with a DAT instruction, potentially corrupting &amp; killing the other process:</p>\n<p>0000: ADD #  4, $ 3<br/>0001: MOV $  2, @ 2<br/>0002: JMP $ -2, # 0<br/>0003: DAT #  0, # 0</p>\r\nLearning Redcode\r\n<p>Read the beginners' guide to Redcode\u00a0a thorough introduction to the Corewar language. Further below you will find an overview of the supported opcodes and address modes in this version of Corewar.</p>\r\nUser Interface\r\n\n<p><em>*main menu screenshot*</em></p>\n<p>When running the cartridge, you enter in the main menu with the following options:<br/><strong>Simulator</strong>\u00a0- run a fight between two warriors<br/><strong>Editor</strong>- write the code for a warrior<br/><strong>Campaign</strong>\u00a0- Complete a list of challenges (not yet implemented)<br/><strong>Manual</strong>\u00a0- In-game details on the instructions.</p>\r\nSimulator\r\n<p><em><br/>*warrior selector screenshot*</em><br/></p>\n<p>Select which two warriors (blue and red) will fight against each other. You can also have a warrior fight a copy of itself.</p>\n<p><em>*simulator intro screenshot*</em></p>\n<p>The warriors are loaded into the core at equal distance (but with a random offset).<br/>The default core-size is 800 cells and will run for 8000 cycles. On the bottom row you can see the current cycle (white #0), the number of blue processes (#1) and the number of red processes (#1).</p>\n<p>When a warrior doesn't have any processes anymore (#0) it loses, if both warriors are still running after 8000 cycles the game is a tie.</p>\n<p>The characters M,J,D,S,A, etc are the first characters of the opcode in the memory, giving you an idea for the \"fingerprint\" of the each warrior. The highlighted character is the current active instruction from the process queue.</p>\n<p>Press \u274e to run / pause the simulation. Press \ud83c\udd7e\ufe0f to step through it one cycle at a time. When the simulation is paused, you can inspect the memory by moving the debug cursor (yellow square) with the arrow keys.</p>\n<p><em>*simulator pause screenshot*</em></p>\n<p>When paused, you can see the memory around the debug cursor (yellow highlighted). The blue and red active instructions are also shown.</p>\n<p><em>*simulator pause screenshot*</em></p>\n<p>After running for a while, you can see that both warriors have spawned multiple processes and filled the core with their data / instructions.</p>\n<p><em>*simulator run screenshot*</em></p>\n<p>Running \u274e the simulation at full speed.</p>\n<p><em>*simulator end screenshot*</em></p>\n<p>The simulation has ended at 8000 cycles, both warriors are still alive (blue with 7 processes and red with 26), resulting in a draw. You can restart \u274e the simulation of go back \ud83c\udd7e\ufe0f to the main menu. If you want to exit the simulation before it has ended, press both the \u274e and \ud83c\udd7e\ufe0f buttons at the same time while paused.</p>\r\nEditor\r\n<p><em>*editor screenshot*</em></p>\n<p>After starting the editor, you can see and change the instructions for the current warrior. Editing is done with the 6 PICO-8 buttons; the 4 arrow keys and the \u274e and \ud83c\udd7e\ufe0f buttons. Within the scope of the editor, the \u274e button is commonly used to edit / confirm and the \ud83c\udd7e\ufe0f button for undo / save &amp; back to the main menu.</p>\n<p>At the top of the screen you can see the name of the current warrior (MICE), the starting position (also indicated by the -&gt; arrow at line 001) and the size (8) of the code.</p>\n<p>The first column are the line numbers (000), followed by the instruction / opcode (DAT), the A-address modifier (#), the A number (0), the B-address modifier (#) and the B address (0).</p>\n<p><em>*edit line screenshot*</em></p>\n<p>Use the up/down buttons to change the current line, you can enter the line edit mode by pressing the \u274e button, which lets you add a new line above/below (up/down) the current line, delete the\u00a0current line (left) and set the start position (right) to the current line. You can make multiple changes while you are in the edit line mode. Press \u274e to confirm the changes or press \ud83c\udd7e\ufe0f to undo.</p>\n<p>Use the left/right buttons to select a column on the current line, you can then edit the column value by pressing the \u274e button.</p>\n<p><em>*edit opcode screenshot*</em></p>\n<p>When editing the opcode, you can cycle through the opcodes with the up/down button. Press \u274e to confirm the change or press \ud83c\udd7e\ufe0f to undo.</p>\n<p><em><br/>*edit address mode screenshot*</em></p>\n<p>When editing the opcode, you can cycle through the opcodes with the up/down button. Press \u274e to confirm the change or press \ud83c\udd7e\ufe0f to undo.</p>\n<p><em><br/>*edit number screenshot*</em></p>\n<p>When editing the A or B number, you can change the number in steps of 1 with the up/down buttons and in steps of 10 with the left/right buttons. Press \u274e to confirm the change or press \ud83c\udd7e\ufe0f to undo.</p>\r\nRedcode\r\n<p>This version of Corewar attempts to follow the Redcode ICWS '94 standard,<br/>with the following limitations for the sake of simplicity and PICO-8 limitations:<br/>- only modes #$@&lt;<br/>- no opcode modifiers (using ICWS'88 defaults)<br/>- no expressions<br/>- no macros<br/>- no ORG, EQU or END pseudo-instructions<br/>- no comments</p>\r\nRedcode instruction set\r\n<p>Opcodes can be divided into six groups:</p>\n<p><strong>Data:</strong><br/>DAT - stores data, the process executing DAT is terminated</p>\n<p><strong>Copying:</strong><br/>MOV - copy the contents of A to B</p>\n<p><strong>Simple Maths:</strong><br/>ADD - add the contents of A to the contents of B<br/>SUB - subtract the contents of A from the contents of B<br/>MUL - multiply the contents of A by the contents of B<br/>DIV - divide the contents of B by the contents of A<br/>MOD - divide the contents of B by the contents of A, taking the remainder</p>\n<p><strong>Flow Control:</strong><br/>JMP - transfer control to A (the contents of B is ignored)<br/>JMZ - transfer control to A if the contents of B are zero<br/>JMN - transfer control to A if the contents of B are non-zero<br/>DJN - decrement the contents of B then transfer control to A if non-zero<br/>SEQ - skip the next instruction if the contents of A and B are equal<br/>SNE - skip the next instruction if the contents of A and B are not equal<br/>SLT - skip the next instruction if the contents of A is less than B</p>\n<p><strong>Process Control:</strong><br/>SPL - create a new process at A (the contents of B is ignored)</p>\n<p><strong>Miscellaneous:</strong><br/>NOP - do nothing (for debugging purposes)</p>\r\nAddresses\r\n<p>Each address has an addressing mode and a pointer. All pointers are relative to where the address is stored. 0 refers to the current location. 1 refers to the next location and -1 to the previous. There are 4 addressing modes:</p>\n<p>$ - direct - address is the location at pointer<br/>\\# - immediate - address is the current instruction<br/>@ - B indirect - the B value of the location at pointer points to the address<br/>&lt; - pre decrement B indirect - decrement the B value of the location at pointer then use B indirect addressing</p>\n<p>All values are taken modulo the size of memory (CORESIZE). Values range from 0 to CORESIZE-1. For example if the CORESIZE is 800, -3 is stored as 797 (CORESIZE-3).</p>", "metacritic": null, "released": "2021-01-10", "tba": false, "updated": "2021-01-11T03:52:46", "background_image": "https://media.rawg.io/media/screenshots/184/1845e93578032eaa2fa232b3ebd73cad.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 100, "game_series_count": 0, "reviews_count": 0, "platforms": ["Web"], "developers": ["mischa_u"], "genres": ["Simulation"], "publishers": [], "esrb_rating": null}