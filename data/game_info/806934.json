{"id": 806934, "slug": "point-and-click-pirate-adventure", "name": "Point-and-Click Pirate Adventure", "name_original": "Point-and-Click Pirate Adventure", "description": "<p>Guide your rat pirate (pirate? bilgerat?) through some islands to collect scrap and a rare power cell that can be used to repair the crew's damaged ship.\u00a0</p>\n<p>All assets and code were created by myself within the space of a single week.</p>\n<p>Controls:</p>\n<ul><li>LMB to move</li><li>RMB to interact</li></ul>\n<p>Be aware this file is pretty large, as it's the first ttime I\u00a0experimented with sound in GameMaker Studio 2, so there's a hefty track of background music in there.</p>\n<p>Most of the code for this game was borrowed from an earlier point-and-click movement system I had attempted. The earlier version, however, suffered greatly from scope bloat and was highly unstable -- this system represents a more refined version of that mechanic.\u00a0</p>\n<p>Relevant move target code:</p>\r\n\r\nif (!obj_gui.paused &amp;&amp; mouse_check_button(mb_left)) \r\n{\r\n    x = mouse_x;\r\n    y = mouse_y;\r\n    image_alpha = 1;\r\n    image_xscale = 1.5;\r\n    image_yscale = 1.5;\r\n}\r\nelse\r\n{\r\n    image_alpha = 1;\r\n    image_xscale = 1;\r\n    image_yscale = 1;\r\n}\r\nif (obj_player.hspeed == 0 &amp;&amp; obj_player.vspeed == 0)\r\n{\r\n    image_alpha = 0;\r\n}\r\n<p>This code is obviously pretty simple, as it just sets the target to the location of the mouse if LMB is down and turns invisible if the player has stopped, either by reaching its destination or hitting a wall.</p>\n<p>Relevant player code:</p>\r\n\r\nif (obj_target.x &gt; x)\r\n{\r\n    image_xscale = 1;\r\n}\r\nelse if (obj_target.x &lt; x)\r\n{\r\n    image_xscale = -1\r\n}\r\nif (distance_to_point(obj_target.x, obj_target.y) &gt; runDist)\r\n{\r\n    move_towards_point(obj_target.x, obj_target.y, runSpd);\r\n    currentSpd = runSpd;\r\n}\r\nelse if (distance_to_point(obj_target.x, obj_target.y) &gt; walkDist)\r\n{\r\n    move_towards_point(obj_target.x, obj_target.y, walkSpd);\r\n    currentSpd = walkSpd;\r\n}\r\nelse if (distance_to_point(obj_target.x, obj_target.y) &gt;= slowDist)\r\n{\r\n    move_towards_point(obj_target.x, obj_target.y, slowSpd);\r\n    currentSpd = slowSpd;\r\n}\r\nelse \r\n{\r\n    speed = 0;\r\n    currentSpd = 0;\r\n}\r\nif (place_meeting(x + hspeed, y + vspeed, obj_collision)\r\n|| place_meeting(x + hspeed, y + vspeed, obj_collision_small))\r\n{\r\n    speed = 0;\r\n    obj_target.x = x;\r\n    obj_target.y = y;\r\n}\r\n<p>This is a lot of code that simply\u00a0allows the player to move at multiple speeds depending on how far away the move target is.</p>\n<p>Ultimately, the code for this prototype wasn't much new to me -- most of the work was put into level design instead. This game was a practice in measured and purposeful level design and I hope that shows in the final product.</p>", "metacritic": null, "released": null, "tba": false, "updated": "2022-06-21T02:11:19", "background_image": "https://media.rawg.io/media/screenshots/346/3469da738d5f9168d98b43c9e8179f14.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 24, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["skinnyK"], "genres": ["Adventure"], "publishers": [], "esrb_rating": null}