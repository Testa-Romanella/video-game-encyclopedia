{"id": 614945, "slug": "ascii-maze-game-for-apple-iie", "name": "ASCII Maze Game for Apple IIe", "name_original": "ASCII Maze Game for Apple IIe", "description": "<p>A simple maze game. Find your way through the randomly generated maze\u00a0to the X to escape!\u00a0\u00a0</p>\n\n<p>Arrow keys to move the little @ symbol (you). Game ends when you reach the X on the map.</p>\n<p>This was a really fun challenge. The restriction for the jam was no more than 10 lines of BASIC for an 8-bit system of your choice, and no more than 72 characters per line.\u00a0 I had to come up with so many non-intuitive ways of doing things to squash everything in to the size restrictions. Set the same variable to the same value 200 times? Sure, why not!\u00a0 Create a one time IF statement so your GOTO works? You betcha!\u00a0 Get lazy at the end and use multiple print statements for formatting?\u00a0 I just want the madness to stop....</p>\n<p>Definitely more like a 4 dimensional logic puzzle than regular programming, but it's been fun.</p>\n<p>I used AppleWin\u00a0for running, testing.\u00a0 I couldn't find a web based emulator that lets you copy and paste code, but it's easy with\u00a0AppleWin.\u00a0 If I\u00a0find an easy way for people to load the program and play it, I'll post it here.\u00a0 Word of warning, this program is optimized heavily for code line length and line count. NOT for efficiency. If you're going to try it out set yourself a timer - it takes about 2 minutes after you type RUN before the maze is displayed. There is however a nice spinning indicator to watch, so at least you'll know the program is doing <em>something. </em>Once the maze loads, everything runs smoothly and you can zip around the maze crashing into walls as people do.</p>\n<p>The maze is created using an unholy mockery of\u00a0Prim's Minimum Spanning Tree algorithm.\u00a0 Per the jam instructions, I will be posting an explanation of the code later. I need a break from this at the moment..</p>\n<p>Here is the full code for your perusal.\u00a0\u00a0<br/></p>\r\n\r\n0HOME:DIMG(40,24):DIMD(3):FORN=0TO3:D(N)=N:NEXTN:I=1:DIML(210,1):H=2:V=2\r\n1J=RND(1)*4:K=RND(1)*4:T=D(J):D(J)=D(K):IFS=0THENDIMQ$(2):Q$(0)=\"#\":S=1\r\n2D(K)=T:FORT=0TO3:N=D(T):O=(N=0)-(N=1):P=(N=2)-(N=3):L(1,0)=H:L(1,1)=V\r\n3X=L(I,0)+O*2:Y=L(I,1)+P*2:E=1:IFX&gt;39ORX&lt;1ORY&gt;23ORY&lt;1ORG(X,Y)THENE=0\r\n4IFETHENT=3:G(X,Y)=1:G(X-O,Y-P)=1:I=I+1:L(I,0)=X:L(I,1)=Y:NEXTT:GOTO1\r\n5HTABH:VTABV:?\"DIGGING\"MID$(\"-\\|/\",T+1,1):NEXTT:I=I-1:Q$(1)=\" \":IFIGOTO1\r\n6G(38,22)=2:Q$(2)=\"X\":FORY=1TO23:FORX=1TO40:?Q$(G(X,Y));:NEXTX,Y\r\n7HTABH-A:VTABV-B:?\" \":HTABH:VTABV:?\"@\":WAIT49152,128:K=PEEK(49152)-128\r\n8A=(K=21)-(K=8):B=(K=10)-(K=11):T=G(H+A,V+B):IFT=0THENA=0:B=0:?CHR$(7)\r\n9H=H+A:V=V+B:POKE49168,0:ONT&lt;2GOTO7:?\"\":?\"\":?\"YOU'RE FREE!\":END\r\n<p>[Update] Added a disk image! Now you can download the disk image, then go to\u00a0https://www.scullinsteel.com/apple2/\u00a0and drag and drop the disk image onto the Apple II emulator to play.</p>\n<p>[Update]\u00a0Okay, per the jam instructions, here is an explanation of the code:</p>\r\n\r\n==[ LINE 0 ]==========================================\r\n0HOME:DIMG(40,24):DIMD(3):FORN=0TO3:D(N)=N:NEXTN:I=1:DIML(210,1):H=2:V=2\r\n------------------------------------------------------\r\nHOME // Clears the screen.\r\nDIM G(40, 24) // Creates an array to hold the maze grid. Apple IIe text mode resolution is 40x24\r\nDIM D(3) // Array for holding possible directions. This will be shuffled for randomized direction checking.\r\nFOR N = 0 TO 3 // Need to set all four directions to a number\r\nD(N) = N // Use the numbers from the FOR loop to set the initial state of D() to 0,1,2,3\r\nNEXT N // Loop until N = 3\r\nI=1 // Index for the list of spaces that still need to be checked as a possible maze path.\r\nDIM L(210,1) // An array to hold the List of spaces that need to be checked. The max possible number of spaces is only 209 (38/2)*(22/2). I don't know why I made it 210.\r\nH=2 // Initial starting X location for maze generator.\r\nV=2 // Initial starting Y location for maze generator.\r\n======================================================\r\n==[ LINE 1 ]==========================================\r\n1J=RND(1)*4:K=RND(1)*4:T=D(J):D(J)=D(K):IFS=0THENDIMQ$(2):Q$(0)=\"#\":S=1\r\n------------------------------------------------------\r\nJ = RND(1) * 4 // Get a random number from 0 to 3\r\nK = RND(1) * 4 // Get another random number from 0 to 3\r\nT = D(J) // Using those two random numbers as locations, we do a swap of two numbers in our direction array. T for Temp?\r\nD(J) = D(K) // Swap isn't quite finished. That happens on the next line.\r\nIF S = 0 THEN DIM Q$(2) // Needed a place to create this array so used an IF statement that is designed to only run once. Uninitialized variables are set to 0 in Applesoft BASIC.\r\nQ$(0) = \"#\" // This array is to hold the \"graphics\" for drawing the maze. 0=# (walls)\r\nS = 1 // Set S to 1 so this IF statement will not run again.\r\n======================================================\r\n==[ LINE 2 ]==========================================\r\n2D(K)=T:FORT=0TO3:N=D(T):O=(N=0)-(N=1):P=(N=2)-(N=3):L(1,0)=H:L(1,1)=V\r\n------------------------------------------------------\r\nD(K) = T // Finish doing the direction shuffle\r\nFOR T = 0 TO 3 // Re-using T for this FOR loop\r\nN = D(T) // What direction do we check first?\r\nO = (N = 0) - (N = 1) // If N is 0, then this evaluates to 1. If not, it evaluates to 0. So if N is 0, this would read O = 1 - 0\r\nP = (N = 2) - (N = 3) // If N was 3, then this would read as P = 0 - 1. This technique gives us four possible outcomes for (O,P). (1,0), (-1,0), (0,1), (0,-1)\r\nL(1, 0) = H // Set the first position of our list of positions to H,V.\r\nL(1, 1) = V // These two lines run over and over setting this position to the same X,Y but it doesn't matter because if the list ever gets to 0 then the maze generator stops.\r\n======================================================\r\n==[ LINE 3 ]==========================================\r\n3X=L(I,0)+O*2:Y=L(I,1)+P*2:E=1:IFX&gt;39ORX&lt;1ORY&gt;23ORY&lt;1ORG(X,Y)THENE=0\r\n------------------------------------------------------\r\nX = L(I, 0) + O * 2 // O * 2 because we are checking two spaces away to see if we can carve a tunnel there.\r\nY = L(I, 1) + P * 2 // We take the X,Y if the top location on our list, then add the offset O,P to get the X,Y to check\r\nE = 1 // The following IF was too long for line 4, so we are using E to teleport the result of the check to the next line\r\nIF X &gt; 39 OR X &lt; 1 OR Y &gt; 23 OR Y &lt; 1 OR G(X, Y) THEN E = 0 // Check X,Y to see if it's out of bounds, or if G(X,Y) already has a tunnel (0 = false)\r\n======================================================\r\n==[ LINE 4 ]==========================================\r\n4IFETHENT=3:G(X,Y)=1:G(X-O,Y-P)=1:I=I+1:L(I,0)=X:L(I,1)=Y:NEXTT:GOTO1\r\n------------------------------------------------------\r\nIF E THEN T = 3 // By setting T to 3, the next NEXT T will exit the loop. IF E is false, Applesoft BASIC will skip the rest of the statements in this line\r\nG(X, Y) = 1 // If we are here, the X,Y location must be good. Set it to 1 (floor)\r\nG(X - O, Y - P) = 1 // Since the X,Y location we checked was two spaces away, back off one space and carve that too.\r\nI = I + 1 // We have a new valid space to add to our list.\r\nL(I, 0) = X // Add the X of space index I to the list.\r\nL(I, 1) = Y // Add the Y of space index I to the list.\r\nNEXT T // We found a valid space to carve in to, and since we set T to 3, we can now end the FOR loop.\r\nGOTO 1 // If we found a valid space, we need to check it's neighbors. Lets do it all again.\r\n======================================================\r\n==[ LINE 5 ]==========================================\r\n5HTABH:VTABV:?\"DIGGING\"MID$(\"-\\|/\",T+1,1):NEXTT:I=I-1:Q$(1)=\" \":IFIGOTO1\r\n------------------------------------------------------\r\nHTAB H // I had some extra room on this line, \r\nVTAB V // so I re-used H and V to set the screen location for the following\r\n? \"DIGGING\" MID$(\"-\\|/\", T + 1, 1) // ? is the same as PRINT in Applesoft BASIC. You also don't need any special characters to concatenate. \r\n// MID$ uses the T variable to go through the string \"-\\|/\" and prints one of those after \"DIGGING\" to do the random spinny animation.\r\nNEXT T // This whole line is what runs when the direction we checked doesn't reveal a valid new location to carve in to. This NEXT says to keep checking until we check all four directions.\r\nI = I - 1 // If we didn't find a new direction to carve, then step back one place on our list of locations we've visited.\r\nQ$(1) = \" \" // Just crammed this in here because I needed to put it somewhere. 1=\" \" (floor)\r\nIF I GOTO 1 // If our index is not 0 (false) then we still have spaces to check that we might be able to branch off of.\r\n======================================================\r\n==[ LINE 6 ]==========================================\r\n6G(38,22)=2:Q$(2)=\"X\":FORY=1TO23:FORX=1TO40:?Q$(G(X,Y));:NEXTX,Y\r\n------------------------------------------------------\r\nG(38, 22) = 2 // Crammed this in here. This the location for X, our exit from the maze\r\nQ$(2) = \"X\" // Last tile to define.  2=X (exit)\r\nFOR Y = 1 TO 23 // Since we draw the maze wall-space-wall, the size will always be odd. So 24-1 max height.\r\nFOR X = 1 TO 40 // Except to save code space we are drawing an extra column of walls...\r\n? Q$(G(X, Y)); // Checked the number in the grid G and PRINTs the correct tile to the screen.\r\n// The trailing semi-colon tells the PRINT (?) statement to not go to the next line after printing.\r\nNEXT X, Y // Loop through the rows and columns.\r\n======================================================\r\n==[ LINE 7 ]==========================================\r\n7HTABH-A:VTABV-B:?\" \":HTABH:VTABV:?\"@\":WAIT49152,128:K=PEEK(49152)-128\r\n------------------------------------------------------\r\nHTAB H - A // Need to erase the player from their old location, so we subtract the offset.\r\nVTAB V - B // If this is the first loop through, it's just 0.\r\n? \" \" // Draw a space where the player was.\r\nHTAB H // Move the cursor to the players new location\r\nVTAB V // the players new location.\r\n? \"@\" // Draw the player.\r\nWAIT 49152, 128 // Sekret Apple code to wait for a keypress.\r\nK = PEEK(49152) - 128 // Get the key that was pressed from the keyboard buffer.\r\n======================================================\r\n==[ LINE 8 ]==========================================\r\n8A=(K=21)-(K=8):B=(K=10)-(K=11):T=G(H+A,V+B):IFT=0THENA=0:B=0:?CHR$(7)\r\n------------------------------------------------------\r\nA = (K = 21) - (K = 8) // Same as what we did in line 2, only this time we're checking what key was pressed.\r\nB = (K = 10) - (K = 11) // 21,8,10,11 for right,left,down,up. You could also use 68,65,83,87 for W,A,S,D.\r\nT = G(H + A, V + B) // Find out what is in the location we want to move to.\r\nIF T = 0 THEN A = 0 // If it's a wall (0) \r\nB = 0 // then we won't move there.\r\n? CHR$(7) // Printing character 7 makes a beep. That's what you get for running into a wall.\r\n======================================================\r\n==[ LINE 9 ]==========================================\r\n9H=H+A:V=V+B:POKE49168,0:ONT&lt;2GOTO7:?\"\":?\"\":?\"YOU'RE FREE!\":END\r\n------------------------------------------------------\r\nH = H + A // If A and B were a good offset location, then this will set H and V to the new locations.\r\nV = V + B // If not, then they equal 0 so this does nothing.\r\nPOKE 49168, 0 // clear the keyboard buffer and get ready for more player button mashing.\r\nON T &lt; 2 GOTO 7 // This was a fun one. I wanted an IF, but that would require an extra line of code that I didn't have.\r\n? \"\" // So what ON GOTO does is takes a list of locations to go to (in this case only one), then it uses the number\r\n? \"\" // specified after the ON to pick the location. In this case we do a compare to see if T less than 2. If it's not, then it means we have reached the exit.\r\n? \"YOU'RE FREE!\" // So if T is 0 or 1, then T&lt;2 will evaluate to 1 which will then GOTO the first location on the list. If it evaluates to 0 (false),\r\nEND // then it skips the GOTO and just keeps executing the rest of the line. Which is just printing out message that you're free and then ending the program.\r\n======================================================", "metacritic": null, "released": "2021-06-03", "tba": false, "updated": "2021-06-07T09:29:08", "background_image": "https://media.rawg.io/media/screenshots/795/7956003bea926945907147e33b504cbf.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 19, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["mauszozo"], "genres": [], "publishers": [], "esrb_rating": null}