{"id": 387691, "slug": "eae6320_assignment9_writeup", "name": "EAE6320_Assignment9_WriteUp", "name_original": "EAE6320_Assignment9_WriteUp", "description": "<p><strong>Details of the Assignment:</strong></p>\n<ul><li>The purpose of the assignment was to make a separate binary effect file that loads the shaders for us so instead of passing both vertex shader and fragment shaders as inputs we only pass the effect file path to get both vertex and fragment shaders.\r\n  </li></ul>\n<p><strong>Running Part of Game:</strong></p>\n<ul><li>The game has following controls:   <ul><li>\u201cW\u201d is used to move object forward(z+)\r\n  </li><li>\u201cS\u201d is used to move object backward(z-)\r\n  </li><li>\u201cA\u201d is used to move object left(x+)\r\n  </li><li>\u201cD\u201d is used to move object right(x-)\r\n  </li><li>\u201cE\u201d is used to move object up(y+)\r\n  </li><li>\u201cQ\u201d is used to move object down(y-)\r\n  </li><li>\u201cTAB\u201d is used to switch between objects\r\n  </li><li>\u201cUP\u201d is used to move camera forward(z+)\r\n  </li><li>\u201cDOWN\u201d is used to move camera backward(z-)\r\n  </li><li>\u201cLEFT\u201d is used to move camera left (x-)\r\n  </li><li>\u201cRIGHT\u201d is used to move camera right (x+)\r\n  </li><li>\u201cPAGE UP\u201d is used to move camera up (y+)\r\n  </li><li>\u201cPAGE DOWN\u201d is used to move camera down(y-)</li></ul></li></ul>\n\n<p><em>Fig 1. Running part of game</em></p>\n<p><strong>How I reach till this point:</strong>\n</p>\n<ul><li>Similar to assignment 8, in this assignment we had to create a new build project which creates our effect files, which can be used to copy shader files directly and not adding the path to assetsToBuild\r\n  </li><li>It took me quite a while to actually find my vertex shader and fragment shader path while registering the shaders with my effect but once it was done the entire thing was simple\r\n  </li><li>Along with my shader paths my effect file also has render state properties, which are useful during creation of shaders\r\n</li></ul>\n<p><em>Fig 2. Color Switcher effect human readable file</em>\n</p>\n<ul><li>This human readable file contains the source path to my shaders, and not the actual build path which the game would need to run these shaders\r\n  </li><li>So, while creating the binary file, I am converting these source path to build path, and I am changing the render state property into 8-bit value so that I can directly use it at run time\r\n  </li><li>Here the binary representation of my colorswitcher binary file\r\n</li></ul>\n\n<p><em>Fig 3. Binary representation</em></p>\n<ul><li>The orange line is render state bits, green box is vertex shaders, blue box is fragment shaders\r\n  </li><li>I have added \u201cdata/\u201d inside my binary file, because we created binary file to reduce the run time computation time and the game only needs the data, through which it can directly run itself\r\n  </li><li>The reason I said that it saved computation time is because, The path to the shaders is a char pointer, and we know that files are going to be inside \u201cdata/\u201d folder so during run time after getting the char pointer to the path we need to create a new char pointer with more length \u00a0and starting from \u201cdata/\u201d and then, append the path to it, which is waste of computation time as well as memory\r\n  </li><li>This is why, I am adding \u201cdata/\u201d at the start of each path\r\n  </li><li>As the paths are a continuous string it has 2 different ways to get the 2nd path after getting the 1st path\r\n  </li><li>I could get the first path as string directly by giving starting pointer, as the path is a string with \u201c\\0\u201d character, which makes it simple to read at the run time, you can see it image below, the draw back of this method is that I need to find the length of string at runtime which takes little computation time but it keeps my binary file as small as possible.\r\n  </li><li>The 2nd way is to store the length of my first path which can make getting the other path in O(1) time has I only have to pass this length and then increase the pointer by that length, to get to the second path, but doing this also required to add \u201c\\0\u201d character at the end of the path to stop it from reading extra memory,   </li><li>Due to this, we need to added \u201c\\0\u201d anyway to both the ways, so why not use it and save memory on disk\r\n</li></ul>\n\n<p><em>Fig 4. Reading call to my binary file</em></p>\n<p><strong>Optional Challenge:</strong>\n</p>\n<ul><li>The optional challenge this time was to make shader files platform independent   </li><li>It was done in 2 steps,   </li><li>First step was to make constant buffer for both direct3D and OpenGL\r\n  </li><li>Second step was to make main function platform independent\r\n  </li><li>For making the constant buffer platform independent, I had created multiple macros to shader.inc, which is the file all shaders include before anything else.\r\n  </li><li>Moreover, main function also needs some macros, as direct3D use float4 and OpenGl uses vec4\r\n  </li><li>Here\u2019s the view of my Constant buffer\r\n  </li><li>Also, as open GL, has out position by default as gl_position, I named my Direct3D output variable as gl_position, so that both Direct3D and open gl has same name, so that I don\u2019t have to use #if directive for each\r\n</li></ul>\n\n<p><em>Fig 5. Constant buffer for my shader class</em></p>", "metacritic": null, "released": "2019-10-31", "tba": false, "updated": "2019-11-01T04:42:10", "background_image": "https://media.rawg.io/media/screenshots/6f2/6f215baca646ce7fdf5597d77524619a.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 7, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["M17D05"], "genres": [], "publishers": [], "esrb_rating": null}