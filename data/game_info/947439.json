{"id": 947439, "slug": "msx-dino-msx-by-albs-br", "name": "MSX-Dino (MSX) by albs-br", "name_original": "MSX-Dino (MSX) by albs-br", "description": "<p># msx-dino.bas</p>\n<p>https://github.com/albs-br/msx-dino.bas</p>\n<p>Attempt to recreate the famous Chrome browser Dino game on a 10-liner MSX-Basic program</p>\n<p>It can be run on any MSX machine (all generations) or MSX emulator by loading the file \"DiskImage.dsk\".</p>\n<p>Can also be run directly on any browser:</p>\n<p>\u00a0 \u00a0 https://msxpen.com/codes/-NR883eaKwP32_gy2gB0 (production version)</p>\n<p>\u00a0 \u00a0 https://msxpen.com/codes/-NR8-A7dx6l4xVtpQTxI (development version)</p>\n<p>Commands:</p>\n<p>- Just use spacebar to jump</p>\n<p>Full explanation of code available in the file \"code explained.bas\"</p>\n<p>Sprites were made with TinySprite. A backup file file is provided (\"tinysprite_bkp.txt\").</p>\n\n<p>code explained</p>\n<p>----------------------</p>\n\n<p>0 ' ------------ Initialization</p>\n<p>1 RESTORE\u00a0 \u00a0 \u00a0 \u00a0' necessary to read DATA on game restart</p>\n<p>2 DEFINT b-z\u00a0 \u00a0 ' integer variables are faster</p>\n<p>3 KEYOFF</p>\n<p>4 SCREEN 1,2,0\u00a0</p>\n<p>5 y = 128\u00a0 \u00a0' initializing only vars with value different from 0 (default value for INT)</p>\n<p>6 m = -1\u00a0 \u00a0 ' Enemy X (set to -1 to force first enemy respawn)</p>\n<p>7 s = 0\u00a0 \u00a0 \u00a0' Score (needs to be reset on each new game)</p>\n<p>8 ON SPRITE GOSUB 70\u00a0 \u00a0 ' setting up collision detection</p>\n<p>9 SPRITE ON\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0' enabling collision detection</p>\n<p>10 ' ------------ Initialization (cont.)</p>\n<p>11 FOR i=0 TO 68</p>\n<p>12\u00a0 \u00a0 VPOKE 6688+(i AND 31), 0\u00a0 \u00a0 \u00a0 ' fill one NAMTBL (32 chars) line with the value of floor tiles (0)</p>\n<p>13\u00a0 \u00a0 READ a$</p>\n<p>14\u00a0 \u00a0 VPOKE 14343+i, VAL(\"&amp;H\" + a$) ' fill SPRPAT for the 3 sprites (69 bytes). (the zeroes on the start/end of patterns are ignored)</p>\n<p>15 NEXT</p>\n<p>16 b = 1\u00a0 \u00a0 ' foreground color = BLACK</p>\n<p>17 f = 15\u00a0 \u00a0' background color = WHITE</p>\n<p>20 ' ------------ Initialization (cont.)</p>\n<p>21 f(0) = 1\u00a0 \u00a0 \u00a0' floor frame #0 (00000001 pattern)</p>\n<p>22 f(1) = 4\u00a0 \u00a0 \u00a0' floor frame #1 (00000100 pattern)</p>\n<p>23 f(2) = 16\u00a0 \u00a0 ' floor frame #2 (00010000 pattern)</p>\n<p>24 f(3) = 64\u00a0 \u00a0 ' floor frame #3 (01000000 pattern)</p>\n<p>25 ' part of sprite pattern data, put here to use empty line space</p>\n<p>26 DATA 4,6,7,23,73,FF,7,3,1,0,0,0,0,0,0,0,0,0,0,80\u00a0</p>\n<p>29 '------------------------------- MAIN LOOP -----------------------------\u00a0</p>\n<p>30 ' ------------ Floor animation</p>\n<p>31 VPOKE 6, f(s AND 3) ' change just one line of the tile pattern #0 (floor tile)</p>\n<p>32 ' ------------ Player jump (between Y coordinates 128 and 81)</p>\n<p>33 IF y &lt; 81 THEN j=3 ELSE IF y = 128 THEN j = STRIG(0)*3 ' STRIG(0) returns -1 when space bar is pressed, making jump control variable (j) equal -3. If not pressed returns 0 making j = 0</p>\n<p>40 ' ------------ Enemy respawn</p>\n<p>41 ' This IF had to be divided in two lines (this one and 50)</p>\n<p>42 IF m &lt; 0 THEN n = 96+INT(RND(1)*3) * 16 : i = b : b = f : f = i : v = s/100 + 2 : IF v &gt; 6 THEN v = 7</p>\n<p>43 ' n = 96+INT(RND(1)*3) * 16\u00a0 ' random new enemy Y value</p>\n<p>44 ' i = b : b = f : f = i\u00a0 \u00a0 \u00a0 ' invert background and foreground colors</p>\n<p>45 ' v = s/100 + 2\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' update current game speed (minimum 2) based on score</p>\n<p>46 ' IF v &gt; 6 THEN v = 7\u00a0 \u00a0 \u00a0 \u00a0 ' cap max game speed to 7</p>\n<p>50 IF m &lt; 0 THEN BEEP : m = 255 : LOCATE 22,1 : ?s : COLOR f,b,4 : p = 0 : IF n = 128 THEN p = s AND 2</p>\n<p>51 ' BEEP</p>\n<p>52 ' m = 255\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' enemy X initial value</p>\n<p>53 ' LOCATE 22,1 : ?s\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0' print score</p>\n<p>54 ' COLOR f,b,4\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' update screen foreground and background colors</p>\n<p>55 ' p = 0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' set enemy pattern to 0 (bird)</p>\n<p>56 ' IF n = 128 THEN p = s AND 2\u00a0 \u00a0 \u00a0 \u00a0 ' if enemy Y is 128 (floor level) it can be pattern 0 (bird) or 2 (cactus)</p>\n<p>60 ' ------------ Gameplay</p>\n<p>61 PUTSPRITE 0, (32, y), f, 1\u00a0 \u00a0' player sprite</p>\n<p>62 y = y+j\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' pleyer Y plus j (jump control variable)</p>\n<p>63 PUTSPRITE 1, (m, n), f, p\u00a0 \u00a0 ' enemy sprite</p>\n<p>64 s = s+1\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' increment score</p>\n<p>65 m = m-v\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' update enemy X based on current game speed (v)</p>\n<p>66 GOTO 30\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' restart main loop</p>\n<p>69 '------------------------------- MAIN LOOP -----------------------------\u00a0</p>\n<p>70 ' ------------ Collision</p>\n<p>71 LOCATE 22, 1\u00a0</p>\n<p>72 ?s\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0' print score</p>\n<p>73 LOCATE 11,11</p>\n<p>74 ? \"GaMeOvEr\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0' print game over string</p>\n<p>75 PLAY \"DFDA\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ' play game over sound</p>\n<p>76 FOR i=0 TO 3000\u00a0 \u00a0 \u00a0 ' wait a few instants</p>\n<p>77 NEXT</p>\n<p>78 SPRITE OFF\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0' disabling collision detection to avoid it being re-triggered on next restart</p>\n<p>80 RETURN 0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0' restart game</p>\n<p>81 ' Sprite data is on hexadecimal, which is less verbose than decimal and binary, saving a few chars.</p>\n<p>82 ' Besides this, data is adjusted in a way that the empty parts of the sprites</p>\n<p>83 ' are on the start and end of the sequence and can be ignored</p>\n<p>84 ' (VRAM is filled with zeroes by the interpreter on initilization)</p>\n<p>85 ' Other trick is trying to put the sprite the rightmost possible inside the</p>\n<p>86 ' 16x16 (or 8x16) box, to give smaller hexa numbers (the left digit can be ignored if is 0)</p>\n<p>89 DATA C0,E0,FF,F8,FE,0,0,0,0,0,20,20,31,3F,1F,F,7,7,6,4,6,1E,2F,3F,38</p>\n<p>90 DATA 3F,78,F8,FE,F8,F0,F0,E0,C0,80,80,C0,18,1B,DB,DB,DB,DE,7C,38,18,18,18,18</p>", "metacritic": null, "released": "2023-03-25", "tba": false, "updated": "2023-03-27T10:40:33", "background_image": "https://media.rawg.io/media/screenshots/bb0/bb03ce1a8a31a678680128fbef9ae77a.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 8, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["BASIC 10Liner"], "genres": ["Action"], "publishers": [], "esrb_rating": null}