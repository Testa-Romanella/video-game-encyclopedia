{"id": 462367, "slug": "tiny-x-wing", "name": "Tiny X-Wing", "name_original": "Tiny X-Wing", "description": "<p>This mini-game was made to experiment with some concepts I've been wanting to investigate. Namely, these four things:</p>\n<ul><li>Data-driven gameplay elements, i.e. a method for\u00a0modding</li><li>Rendering a game at a fixed resolution, despite the resolution the user sets.</li><li>What happens if you tie as much of the game as possible to a fixed framerate?</li><li>\"Real world\" testbed for Shapes\u00a0in gameplay and Editor</li></ul>\n<p>Before I\u00a0dive into my devlog-like write up on the technical aspects, here's some quick info on what this little mini-game actually is.</p>\n<p><strong>There will be no further development on this as it has more than served its purpose.</strong></p>\r\nThe Gameplay!\r\n<br/>\n<p>Fly your TIE Fighter against a squadron of X-Wings! Fight alongside your allies, with both sides backed by a Lancer anti-fighter frigate.</p>\n<p>The feel and gameplay are inspired by the classic X-Wing PC games of the 90s, though this is much simpler than those games were.</p>\r\nControls\r\n<p>Gamepad is the preferred method of play, but the\u00a0game can be played with keyboard only as well, using the arrow keys and W/S. All flight controls are listed on screen.</p>\r\nSpectator Camera\r\n<p>After the player is killed, either by gunfire or by pressing the <strong>Self Destruct key (K)</strong>, they are put into a spectator camera and can freely fly around the area to observe the battle.</p>\n<p>To control the spectator camera, hold down the right mouse button and use the\u00a0<strong>WASD\u00a0</strong>keys to move around.</p>\r\nSpawning New Fighters\r\n<p>At any point during the game, new AI fighter squadrons can be spawned in. This was mostly just a debug feature, but it's fun to spawn in more fighters and see what happens.\u00a0</p>\n<p>The Lancer frigates cannot be respawned once they are destroyed.</p>\r\nInstallation\r\n<p>The game can be downloaded and installed manually, or installed via the itch.io app. The official itch app provides a Steam like launcher for downloading and installing games and is the most self-explanatory way to play the game. Simply navigate to this game's page, then click the Install button.</p>\n<p>If downloading manually, follow these steps:</p>\n<ol><li>Download the zip file from this page</li><li>Open the zip file and extract the \"TinyXWing\" to a location on your hard drive.</li><li>Inside the <strong>extracted</strong>\u00a0\"TinyXWing\" folder, double click \"TinyXWing.exe\"</li></ol>\n<p>To uninstall the game:</p>\n<ol><li>Delete the extracted \"TinyXWing\" folder.Data Driven Gameplay, a.k.a. \"Mod Support\"</li></ol>\r\nData-Driven Gameplay a.k.a \"Mod Support\"\r\n<p>This was the driving factor behind this game, and is related to something of a long-standing chip of my shoulder with modern game development. First, some backstory.</p>\r\nHow games used to be made\r\n\n<p>Traditionally when you set out to make a video game, you would write the game from\u00a0scratch. \"Engine\"\u00a0and game were often synonymous, and since you were writing it all yourself, it also meant you often had to write your own tools to develop the game with. Making it so a game reads from files stored in the computer, that are easily accessible and editable by game designers, makes development of the game faster and easier than if everything were hard-coded into the game's code.</p>\n<p>A fortunate side effect of this practice meant that players could often open these very same files and edit them to build mods and customize their experience. This wasn't always intended by developers, but it was more often than not a welcome feature and many of the biggest games in the world have their roots in video game modding.</p>\r\nHow (many) games are made now\r\n\n<p>Fast forwarding to today, game developers now have ready access to off the shelf engines such as Unreal and Unity. A peculiar feature of these engines is that they have\u00a0<strong>built in Editors</strong>. Instead of having to write your own model importers, your own animation tools, your own level creators, and so on, you now have this awesome development environment where you can do it all!\u00a0</p>\n<p>This is\u00a0<em>fantastic</em>. Never before has making a game been so easy, accessible, and intuitive. You no longer require the specialized knowledge in many disparate disciplines\u00a0to write your own technology stack. You can start from something that already works, and focus on building the\u00a0<em>game</em>.\u00a0</p>\n<p>However, something was lost with this approach. In order for development and games to be optimized for the Editor experience, this necessarily means that a lot what\u00a0used to be easily editable and readable game data now resides within these Editor tools. Instead of setting the parameters for what makes an X-Wing in a text file that then gets loaded, you can just set up an X-Wing inside the editor and see your changes immediately. While this vastly speeds up iteration time, it comes the trade off of easily accessible game data from the user's standpoint. For most developers and games, this is a trade off that is\u00a0<em>well worth</em>\u00a0<em>it</em>.\u00a0</p>\r\nMaking a Unity Game Moddable\r\n\n<p>This brings us back to the original point. My main goal with this project was to get rudimentary elements of the game to be driven by easily accessible files on the hard drive. This is completely counter to how Unity (and Unreal)\u00a0are designed to operate. In many ways, you are making your own life far more difficult for little to\u00a0no practical gain in terms of the development process.</p>\n<p><em>* At this point I feel I\u00a0must point out that there are exceptional circumstances where it makes sense to build your game like this, but for the vast majority, it would only be a hindrance.</em></p>\n<p>To that end, many of the ship's properties in this game are loaded from a handful of files that reside in \"TinyXWing_Data\\StreamingAssets\\Ships\". I\u00a0recommend taking a peek at these files, modifying them, and reloading the game to experiment.</p>\n<p>From a developer standpoint it's quite irritating to design a Unity game around this kind of methodology, but it was something I\u00a0really wanted to try. There's a certain satisfaction I get, as an old modder, of seeing game data laid out so plainly and accessible. It also had some very interesting side effects in terms of how I\u00a0had to lay out and structure the game code in order for it to be flexible enough to handle this sort of thing.\u00a0</p>\n<p>This is far from the only way to achieve modding in Unity, but that's a topic far bigger in scope than this game/post. I\u00a0will say though that in my experience, Kerbal Space Program is the golden standard for how far a data driven approach can be pushed in Unity. It really is something to behold.</p>\r\nRunning at a Fixed Resolution (640x480)\r\n\n<p>Not too much to say about this one, I\u00a0just thought it would be fun to go for the \"authentic experience\" and try to mimic some of the old games' quirks just to see where that takes me. 640x480 was a very common resolution back in the later DOS years, so I wanted to see what I\u00a0could do to force, and its aspect ratio,\u00a0this regardless of what resolution the game is running at.</p>\n<p>I\u00a0don't know if there's a better way, but I achieved it by rendering the entire game to a render texture of fixed size (640x480) and then stretching it to fill the screen, while maintaining aspect ratio. Pretty straightforward stuff.</p>\r\nRunning All Logic at a Fixed Update Rate of 30hz\r\n\n<p>As a developer there is quite the allure to running all (or at least as much as possible)\u00a0of a\u00a0game's logic\u00a0at a fixed rate, especially if it's a relatively low one like 30hz. I\u00a0would even say it's a\u00a0<em>luxury</em>. The main benefit this has is that it makes the game far more predictable, stable, and consistent. For certain kinds of games,\u00a0having these kinds of guarantees can make things tremendously easier to work with.<br/></p>\n<p>I also noticed that it reframed how I\u00a0thought about adding features. Whereas typically I\u00a0think about features in terms of \"how much of an FPS hit is this going to result in?\", with a fixed framerate it instead becomes \"how many things can I\u00a0add in before it starts to impact performance?\"</p>\r\nUsing \"Shapes\"\u00a0in a Practical Environment\r\n\n<p>I've long been annoyed at the difficulty that Unity has with drawing clean and pixel perfect lines. Freya\u00a0Holmer has developed the plugin of my dreams, Shapes. It was just released and having used it only in demo environments I\u00a0was curious to trial it in a simple standalone and practical project before taking the plunge and attempting to integrate it into Tiny Combat.</p>\n\n<p>In this project, I\u00a0used it for debug visuals (seen above), the stars in the skybox, and as an aid in drawing the lasers so that lasers always appeared as continuous pixel lines even when far from the camera. It's a joy to work with and I\u00a0highly recommend it!</p>", "metacritic": null, "released": "2020-07-04", "tba": false, "updated": "2020-07-06T04:09:20", "background_image": "https://media.rawg.io/media/screenshots/cd3/cd3050d1b23e7940f61f202630e61754.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 45, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["Why485"], "genres": ["Simulation"], "publishers": [], "esrb_rating": null}