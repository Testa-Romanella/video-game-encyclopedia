{"id": 123151, "slug": "lisp-vs-blub-empire", "name": "Lisp vs Blub Empire", "name_original": "Lisp vs Blub Empire", "description": "Story:\r\n\r\n<p>Lisp is the best language. But the Blub Empire is taking over the world!<br/>Fight for your favorite programming language in this Medieval Strategy Game.</p>\n<p>This game is an entry for the <strong>Lisp Game Jam 2018</strong>.</p>\n<p>Sorry for the dumb AI, it is definitely bad, but I didn't got the time to make it fun to play against.</p><p><strong>Don't hesitate to zoom the page to better see the game.</strong><br/></p>\r\nHow to play:\r\n\r\n<p>I - move the cursor up<br/>K - move the cursor down<br/>J - move the cursor left<br/>L - move the cursor right<br/>H - action<br/>G - cancel</p>\n<p>When a unit is selected:<br/>Action(H) on an empty tile - Move<br/>Action(H) on an opponent next to the unit - Attack<br/>Action(H) with cursor on the unit - Use one coin to level up the unit</p>\r\nTechnical details:\r\n\r\n<p>The game is written in a custom Lisp language called <strong>wasm-adventure</strong> (written in Racket) that transpiles directly to WebAssembly.</p>\n<p>This means the game does not use any framework nor graphics engine. I had to build everything from the ground up byte by byte in assembly, then write utility functions to draw to the screen (which basically consists in writing bytes to a specific location in memory).</p>\n<p>I wanted to try that because WebAssembly in its text format actually uses s-expressions. If I can write a lisp language that generates s-expressions, I can generate WebAssembly.</p>\n<p>You can check out the code on Github here. To jump directly to the game code, see this file.</p>\r\nUnder the hood example:\r\n\r\n<p>A simple wasm-adventure function I wrote:</p>\r\n\r\n(func move-cursor-up ()\r\n  (locals pos)\r\n  (set-local pos (load-byte (mem 'game 'cursor-pos)))\r\n  (store-byte (mem 'game 'cursor-pos) (call 'row-up pos)))\r\n\r\n<p>Then Racket transforms the code into a WebAssembly function:</p>\r\n\r\n(func $move-cursor-up (local $pos i32)\r\n  (set_local $pos (i32.load8_u (i32.const 7878)))\r\n  (i32.store8 (i32.const 7878) (call $row-up (get_local $pos))))\r\n<p>Then the web assembly toolkit resolves the code into this 1-to-1 equivalent WebAssembly binary:</p>\r\n\r\n(func $func18\r\n  (local $var0 i32)\r\n  i32.const 7878\r\n  i32.load8_u\r\n  set_local $var0\r\n  i32.const 7878\r\n  get_local $var0\r\n  call $func12\r\n  i32.store8)\r\n<p>As you can see, this looks fairly close to actual CPU assembly, except it runs in the browser!</p>", "metacritic": null, "released": "2018-04-25", "tba": false, "updated": "2019-08-28T23:23:36", "background_image": "https://media.rawg.io/media/screenshots/6b7/6b792dd6a707a56c90b759f21e441719.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 17, "game_series_count": 0, "reviews_count": 0, "platforms": ["Web"], "developers": ["euhmeuh"], "genres": ["Strategy"], "publishers": [], "esrb_rating": null}