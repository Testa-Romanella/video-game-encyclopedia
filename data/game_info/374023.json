{"id": 374023, "slug": "eae-game-engineering-ii-assignment-03", "name": "EAE Game Engineering II Assignment 03", "name_original": "EAE Game Engineering II Assignment 03", "description": "<p><strong>Warning to folks who want to download the OpenGL version. It doesn't really work. I'll update it with the fixed version soon!</strong></p>\n<p><strong>Assignment Write Up:</strong></p>\n<ul><li><strong>Show a screenshot of your game running</strong><ul><li>Hey, look. A screenshot!</li></ul></li><li><strong>Explain how you made Graphics.cpp platform-independent:</strong><ul><li>To be honest, I was just a\u00a0<em>little</em> bit annoyed about that we had to delete the Graphics.d3d.cpp and Graphics.gl.cpp files in creating our new Graphics.cpp file. If I could create some helpful functions that contained the platform-specific code in those files and then were called through non-platform-specific interfaces in Graphics.cpp, I think the code would have been very nice and seamless. I don't know, maybe I just liked the idea of being able to plug the platform-specific piece of Graphics.cpp onto the \"main\" piece of Graphics.cpp. If that made any sense. Anyway, I just created a Graphics-Utils file that held that information.\u00a0I was reading through some of the other people's write ups after I did that and really liked the idea of having a \"Device\" namespace. In true programmer fashion, I'm just terrible at naming things.\n<ul><li><strong>What new interfaces did you have to create?\u00a0Where did you decide to declare these interfaces?</strong><ul><li>I think I mostly answered this in my previous ramble, but I basically made a single interface that allowed for platform specific functions in Init, Draw and CleanUp that are called in each of the \"main\" graphics functions. Of course, if there's nothing platform specific to be done, then nothing happens.</li></ul></li><li><strong>Where did you define the platform-specific implementations for these interfaces?</strong><ul><li>In their own .d3d.cpp and .gl.cpp files. Successfully resisted the urge to use preprocessor directives.</li></ul></li></ul></li></ul></li><li><strong>Show us your code in the Graphics.cpp file that clears the back buffer color</strong><ul><li>Hey, more pictures!</li></ul></li><li><strong>Show a screenshot of your game with a clear color (i.e. background) other than black</strong><ul><li>I think that's already in the main image. I like teal.</li></ul></li><li><strong>Show code from your Graphics.cpp file that initializes an effect</strong><ul><li>Effects are initialized by passing in an EffectInitParams struct to the Initialize() method on the Effect object. The struct just contains the two string paths to the vertex shader and the fragment shader.</li></ul></li><li><strong>Tell us how much memory a single effect takes up in both platforms (use sizeof() with a debugger rather than guessing). Is there any way to make it smaller?</strong><ul><li>OpenGL took 16 bytes and Direct3D took 12 bytes. I'm not convinced it can really get smaller than this, but I think we could optimize memory by using the same Effect instance on multiple objects that use it instead of creating a new instance for each.</li></ul></li><li><strong>Show code from your Graphics.cpp file that initializes a 3D object</strong><ul><li>The geometry object is initialized in a similar way to the effects. We fill up a GeometryInitParams struct with the data we need and pass that to the Initialize() method on the geometry object. For this struct, we need the vertex data, the number of vertices, the index data and the number of indices.</li></ul></li><li><strong>Tell us how much memory a single object takes up in both platforms (use sizeof() with a debugger rather than guessing). Is there any way to make it smaller?</strong><ul><li>OpenGL took 28 bytes and Direct3D took 44 bytes. I'm suddenly not sure this is actually correct, but I'm pretty sure my code is right, so it must be?\u00a0 I imagine that being able to combine Geometry objects with common vertices will help reduce the overall memory use of these objects.</li></ul></li></ul>\n<p><strong>Issues I ran into:</strong></p>\n<p>There are two major issues I haven't been able to fix.</p>\n<p>1) The\u00a0cVertexFormat manager seems to thing there's an asset that hasn't been released, but I can't find where it is. I'll keep searching, because it's probably just my sleep-addled brain being unable to find it. It's been a wild week.</p>\n<p>2) Okay so this is super weird: the x86 build actually freezes on running, but only when you run the build on its own. While debugging, it works fine. This makes debugging the actual problem really hard because I literally can't find any issues using the debugger. I guess it's time to litter my code with log-output statements and keep checking the log file.</p>", "metacritic": null, "released": "2019-09-12", "tba": false, "updated": "2019-09-13T06:33:26", "background_image": "https://media.rawg.io/media/screenshots/e3f/e3f07e8c1e75da9b3a42cb14e1c254b0.jpg", "website": "", "rating": 0.0, "rating_top": 0, "added_by_status": null, "playtime": 0, "achievements_count": 0, "ratings_count": 0, "suggestions_count": 27, "game_series_count": 0, "reviews_count": 0, "platforms": ["PC"], "developers": ["TheDarkMiko"], "genres": [], "publishers": [], "esrb_rating": null}